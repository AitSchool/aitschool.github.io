(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{1713:function(a,t,r){"use strict";r.r(t);var i=r(0),e=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"从今天起，重新理解前端"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#从今天起，重新理解前端","aria-hidden":"true"}},[a._v("#")]),a._v(" 从今天起，重新理解前端")]),r("h2",{attrs:{id:"前端发展史：从青铜到黄金时代"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端发展史：从青铜到黄金时代","aria-hidden":"true"}},[a._v("#")]),a._v(" 前端发展史：从青铜到黄金时代")]),r("h3",{attrs:{id:"前端的史前记忆：“青铜时代”"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端的史前记忆：“青铜时代”","aria-hidden":"true"}},[a._v("#")]),a._v(" 前端的史前记忆：“青铜时代”")]),r("p",[a._v("2006 年，网页的主要交互都还是依靠切换超链接来完成。谷歌刚刚基于 Ajax 发布的 Gmail 也没多久，虽然这项伟大的技术标志着 Web 1.0（静态网页）到 Web 2.0（动态网页）的迈进。")]),r("h3",{attrs:{id:"进入发展期的前端：“白银时代”"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#进入发展期的前端：“白银时代”","aria-hidden":"true"}},[a._v("#")]),a._v(" 进入发展期的前端：“白银时代”")]),r("p",[a._v("2008 年，前端技术开始了它的大踏步发展，前端逐步从后端分离了出来，它的代码也变得复杂了起来，还需要保存数据、处理数据、生成视图等等。")]),r("h3",{attrs:{id:"从前端到“全端”：“黄金时代”"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#从前端到“全端”：“黄金时代”","aria-hidden":"true"}},[a._v("#")]),a._v(" 从前端到“全端”：“黄金时代”")]),r("p",[a._v("前端团队的各种基础设施也逐渐建立了起来，从最开始的多屏适配方案、基础库、工具链到页面搭建平台和性能体系，最后到客户端融合方案 Weex。")]),r("p",[a._v("与此同时，随着移动时代的到来，前端也开启了自己的“黄金时代”，它的职责变得更加重要，有了独立的发布权限，技术也变得更加复杂。")]),r("p",[a._v("一些传统软件开发和互联网服务端的方法论逐步移植到前端开发中，并形成了前端自己的工程体系，诸如持续集成、前后端分离、线上监控。")]),r("p",[a._v("架构方面，前端架构的任务也从简单的解决兼容和风格问题，逐步过渡到提倡组件化和 UI 架构模式，最后形成了新一代的前端框架 React、Vue 和 Angular，他们也在竞争和互相学习中成长。")]),r("h2",{attrs:{id:"前端开发之痛：散点自学-基础不牢"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端开发之痛：散点自学-基础不牢","aria-hidden":"true"}},[a._v("#")]),a._v(" 前端开发之痛：散点自学 + 基础不牢")]),r("p",[a._v("在面试应届生过程中，我会习惯性地问表现比较好的同学“你是如何学习前端的”，而我得到的答案多是“自学”“在社团学习”，却从未听到过“在学校学习过”这样的答案。")]),r("p",[a._v("而对于工作之后的前端开发者来说，没有系统学习的问题仍然存在，常常有一些具有多年从业经验的工程师，仍然会在看到一些用法时惊呼：“还可以这样！”")]),r("p",[a._v("在我看来，这些用法都是一些基础的不能再基础的知识点，但是他们却浑然不知。如果深入进去了解，你会发现，表面上看他们可能是一时忘记了，或者之前没注意，但实际上是他们对于前端的知识体系和底层原理没有真正系统地理解。")]),r("p",[a._v("经常能看到一些案例，一些有技术追求、有热情的工程师，因为技术敏感度和主观能动性都不错，所以工作了五六年之后，逐步开始在自己的公司做一些技术管理相关的事情了。但是，由于他们所在公司的业务并不复杂，也没有技术积累，所以他们自身的技术水平其实并不高，可以说还处于非常初级的阶段。做了管理，技术没跟上，并且还错过了最佳的学习时间，这个境遇可想而知，他们在工作中大概率只能是被动地接受需求解决问题，然后也同时焦虑着自己的未来，焦虑着自己的竞争力。")]),r("p",[a._v("关于前端工程师成长，我认为需要两个视角。一是立足标准，系统性总结和整理前端知识，建立自己的认知和方法论；二是放眼团队，从业务和工程角度思考前端团队的价值和发展需要。只有这样做，才能够持续发展，在高速发展的技术和工程浪潮中稳稳立足。")]),r("p",[a._v("在这个专栏里，我将知识分成了四个模块来讲解：")]),r("ul",[r("li",[a._v("HTML 和 CSS；")]),r("li",[a._v("JavaScript；")]),r("li",[a._v("浏览器实践；")]),r("li",[a._v("前端综合应用；")])]),r("p",[a._v("JavaScript 中，从文法和运行时的角度去讨论 JavaScript 语言。它们是互相关联的，而语义就是文法到运行时之间的桥梁；它们分别又是完备的，任何语言特性都离不开两者，所以从语法和运行时的角度，我们都可以了解完整的 JavaScript。")]),r("p",[a._v("HTML 和 CSS，会侧重从语言和设计思想的角度来讲解，我们同样可以对两者的全貌建立一些认知。")]),r("p",[a._v("浏览器部分，包含了浏览器工作的原理和一些重要的 API，包括 BOM、DOM、CSSOM 和其他一些内容。了解了这些知识，你才能把 JavaScript 和 HTML、CSS 连接起来，用 JavaScript 来实现功能。")]),r("h2",{attrs:{id:"明确你的前端学习路线与方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#明确你的前端学习路线与方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 明确你的前端学习路线与方法")]),r("p",[a._v("读几本经典的前端教材，比如《JavaScript 高级程序设计》《精通 CSS》等书籍，去阅读一些参考性质的网站也是不错的选项，比如 MDN。")]),r("h3",{attrs:{id:"第一个方法：建立知识架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第一个方法：建立知识架构","aria-hidden":"true"}},[a._v("#")]),a._v(" 第一个方法：建立知识架构")]),r("p",[a._v("我们先来讲讲什么叫做知识架构？我们可以把它理解为知识的“目录”或者索引，它能够帮助我们把零散的知识组织起来，也能够帮助我们发现一些知识上的盲区。")]),r("p",[a._v("如果我们把一些特别流行的术语和问题，拼凑起来，可能会变成这样：")]),r("ul",[r("li",[a._v("类型转换；")]),r("li",[a._v("this 指针；")]),r("li",[a._v("闭包；")]),r("li",[a._v("作用域链；")]),r("li",[a._v("原型链；")]),r("li",[a._v("...")])]),r("p",[a._v("这其实不是我们想要的结果，因为这些知识点之间，没有任何逻辑关系。它们既不是并列关系，又不是递进关系，合在一起，也就没有任何意义。这样的知识架构，无法帮助我们去发现问题和理解问题。")]),r("p",[a._v("如果让我来做，我会这样划分：")]),r("ul",[r("li",[a._v("文法")]),r("li",[a._v("语义")]),r("li",[a._v("运行时")])]),r("p",[a._v("为什么这样分呢，因为对于任何计算机语言来说，必定是“用规定的文法，去表达特定语义，最终操作运行时的”一个过程。")]),r("p",[a._v("文法可以分成词法和语法，这来自编译原理的划分，同样是完备的。语义则跟语法具有一一对应关系，这里暂时不区分。")]),r("p",[a._v("对于运行时部分，这个划分保持了完备性，我们都知道：程序 = 算法 + 数据结构，那么，对运行时来说，类型就是数据结构，执行过程就是算法。")]),r("p",[a._v("当我们再往下细分的时候，就会看到熟悉的概念了，词法中有各种直接量、关键字、运算符，语法和语义则是表达式、语句、函数、对象、模块，类型则包含了对象、数字、字符串等。")]),r("p",[a._v("这样逐层向下细分，知识框架就初见端倪了。在顶层和大结构上，我们通过逻辑来保持完备性。如果继续往下，就需要一些技巧了，我们可以寻找一些线索。")]),r("h2",{attrs:{id:"第二个方法：追本溯源"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第二个方法：追本溯源","aria-hidden":"true"}},[a._v("#")]),a._v(" 第二个方法：追本溯源")]),r("p",[a._v("有一些知识，背后有一个很大的体系，例如，我们对比一下 CSS 里面的两个属性：")]),r("ul",[r("li",[a._v("opacity；")]),r("li",[a._v("display；")])]),r("p",[a._v("虽然都是“属性”，但是它们背后的知识量完全不同，opacity 是个非常单纯的数值，表达的意思也很清楚，而 display 的每一个取值背后都是一个不同的布局体系。我们要讲清楚 display，就必须关注正常流（Normal Flow）、关注弹性布局系统以及 grid 这些内容。")]),r("p",[a._v("还有一些知识，涉及的概念本身经历了各种变迁，变得非常复杂和有争议性，比如 MVC，从 1979 年至今，概念变化非常大，MVC 的定义几乎已经成了一段公案，但 MVC 原始论文、MVP 原始论文、微软 MSDN、Apple 开发者文档，这些内容里面，MVC 画的图、箭头和解释都完全不同。")]),r("p",[a._v("这种时候，就是我们做一些考古工作的时候了。追本溯源，其实就是关注技术提出的背景，关注原始的论文或者文章，关注作者说的话。")]),r("p",[a._v("操作起来也非常简单：翻翻资料（一般 wiki 上就有）找找历史上的文章和人物，再顺藤摸瓜翻出来历史资料就可以了，如果翻出来的是历史人物（幸亏互联网的历史不算悠久），你也可以试着发封邮件问问。")]),r("p",[a._v("这个过程，可以帮助我们理解一些看上去不合理的东西，有时候还可以收获一些趣闻，比如 JavaScript 之父 Brendan Eich 曾经在 Wikipedia 的讨论页上解释 JavaScript 最初想设计一个带有 prototype 的 scheme，结果受到管理层命令把它弄成像 Java 的样子（如果你再挖的深一点，甚至能找到他对某位“尖头老板”的吐槽）。")]),r("p",[a._v("根据这么一句话，我们再去看看 scheme，看看 Java，再看看一些别的基于原型的语言，我们就可以理解为什么 JavaScript 是现在这个样子了：函数是一等公民，却提供了 new this instanceof 等特性，甚至抄来了 Java 的 getYear 这样的 Bug。")]),r("h2",{attrs:{id:"结语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结语","aria-hidden":"true"}},[a._v("#")]),a._v(" 结语")]),r("p",[a._v("今天我带你探索了前端的学习路径，并提出了两个学习方法：你要试着建立自己的知识架构，除此之外，还要学会追本溯源，找到知识的源头。")])])}],!1,null,null,null);t.default=e.exports}}]);