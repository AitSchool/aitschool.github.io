(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{1595:function(t,e,a){"use strict";a.r(e);var s=a(0),i=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"计算属性与依赖追踪"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算属性与依赖追踪","aria-hidden":"true"}},[t._v("#")]),t._v(" 计算属性与依赖追踪")]),a("ul",[a("li",[t._v("Computed 介绍")]),a("li",[t._v("依赖追踪概念")]),a("li",[t._v("依赖追踪算法")])]),a("h2",{attrs:{id:"computed-介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-介绍","aria-hidden":"true"}},[t._v("#")]),t._v(" Computed 介绍")]),a("p",[t._v("Reative 的数据类型可以帮助我们响应式的实现数据的更新，如果使用过 Vue 我们会发现 Vue 的每个组件的 data 属性都相当于一个 Reactive。但 Reactive 不能覆盖我们全部的使用场景，Computed 在 Vue 当中可以直接的从 data 定义出一个函数动态响应 data 的更新 并更新函数的返回值。就有点类似 Excel 的单元公式计算。")]),a("ul",[a("li",[t._v("从 Excel 到 Computed\n"),a("ul",[a("li",[t._v("Reactive：普通单元格中的原始数据")]),a("li",[t._v("Computed：插入了公式的单元格")]),a("li",[t._v("Reactive 单元格更新时，Computed 单元格根据公式（依赖）自动更新")])])])]),a("h2",{attrs:{id:"依赖追踪概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖追踪概念","aria-hidden":"true"}},[t._v("#")]),t._v(" 依赖追踪概念")]),a("p",[t._v("Computed 函数示例")]),a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{attrs:{class:"token function-variable function"}},[t._v("isEmpty")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{attrs:{class:"token operator"}},[t._v("=>")]),t._v(" data"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("values"),a("span",{attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),a("span",{attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{attrs:{class:"token number"}},[t._v("0")]),t._v("\n")])]),a("ul",[a("li",[t._v("指定 Excel 的公式时，我们需要手动选择公式所依赖的单元格")]),a("li",[t._v("但Computed 函数中，我们"),a("strong",[t._v("没有传入 Computed 的依赖")])]),a("li",[t._v("Computed 如何在 Reactive 更新时自动更新自身？依赖追踪算法")])]),a("h2",{attrs:{id:"依赖追踪算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖追踪算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 依赖追踪算法")]),a("ul",[a("li",[t._v("Reactive 本质上在 set Reactive 时去执行更新")]),a("li",[t._v("Computed 本质上在 get Reactive 时标记依赖")])]),a("ol",[a("li",[t._v("Computed 函数 C 初次求值时，标记 C")]),a("li",[t._v("对 C 求值过程中，获取 Reactive 的值，各 Reactive 的 getter 被触发")]),a("li",[t._v("为每个 Reactive 维护一个依赖者 deps 数组，将 C 添加至数组内")]),a("li",[t._v("求值完成后，标记清空，返回求值结果")]),a("li",[t._v("Reactive 更新时，各 deps 中 C 均在 Reactive setter 中触发，一并更新")])])])}],!1,null,null,null);e.default=i.exports}}]);